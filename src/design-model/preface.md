---
title: 前言
order: 1
date: 2023-01-11
---


# 前言

## 代码与设计模式的关系


- 项目 = 模块 + 沟通 （设计模式可以帮助我们更好得编写模块以及设计模块间的沟通）

## 设计模式扮演的角色


- 帮助我们组织模块 
    - 通过一些设计模式，组织模块间的组成结构
- 帮助我们设计沟通 
  - 有的设计模式可以帮助我们设计模块如何沟通
- 提高代码质量 
  - 通过设计模式，让代码更加优雅

## 设计原则


- 开闭原则
  - 对扩展开放，对修改关闭。要留出具体使用时可供扩展的接口，但是要封装源码，不能给外部修改。
- 单一职责原则 
  - 一个模块只做一件事情
  - 关注对象：模块本身
- 依赖倒置原则 
  - 核心思想：上层模块不要依赖于具体的下层模块，而应该依赖于抽象。
  - 实现思路：在上层模块与下层模块之间添加抽象层，从而保证了上层模块不会由于下层模块的改动而发生剧烈变动。
  - 举个🌰
  ```js
    function food1() {}
    function food2() {}

    order.prototype.orderFood1 = function() {}
    order.prototype.orderFood2 = function() {}

    function resturn(food) {
      var list = {
        food1: new food1(),
        food2: new food2(),
      }
      return list[food];
    }

    function order(order) {
      return resturn(food);
    }
  ```
- 接口隔离原则
  - 接口应该细化，功能应该单一。
  - 关注对象：接口本身。
- 迪米特法则
  - 两个模块可以在不互相了解彼此细节的情况下，通过中介等方式进行间接沟通
- 里氏替换原则
  - 关注点：继承
  - 任何父类使用的地方，都可以用子类去替换。因此要求，子类需要完全继承父类的属性和方法。

## 设计模式的分类


- 创建型 - 优雅地创建对象
  - 工厂模式 - 大量创建对象
  - 单例模块 - 全局只能有我一个
  - 建造者模式 - 精细化组合对象
  - 原型模式 - JavaScript的灵魂  
  
- 结构型 - 优雅地设计代码结构
  - 外观模式 - 给你的一个套餐
  - 享元模式 - 通过共享来减少数量（对象/代码块）
  - 适配者模式 - 用适配代替更改（适配新旧接口）
  - 桥接模式 - 独立出来，然后再对接过去（减少耦合）
  - 装饰者模式  - 更优雅地扩展需求
- 行为型 - 模块之间行为的模式总结，帮助我们组织模块行为
  - 观察者模式 - 我作为第三方转发
  - 职责链模式 - 像生产线一样组织模块，对模块进行增删改
  - 状态模式 - 用状态代替判断
  - 命令模式 - 用命令去解耦（执行者与命令者）
  - 策略模式 - 算法工厂
  - 迭代器模式 - 告别for循环（不了解对象内部就可以遍历对象）
- 技巧型 - 优化代码的技巧
  - 链模式 - 链式调用
  - 惰性模式 - 我要搞机器学习（记录执行状态）
  - 委托模式 - 让别人代替你收快递
  - 等待者模式 - 等你吗都回来再吃饭（多个异步）
  - 数据访问模式 - 一个方便的数据管理器
