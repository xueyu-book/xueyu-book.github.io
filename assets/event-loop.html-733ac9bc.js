import{_ as e,V as a,W as t,a0 as i}from"./framework-afccc25a.js";const r="/assets/docs/daily-qa/event-loop.png",n={},o=i('<h1 id="事件循环" tabindex="-1"><a class="header-anchor" href="#事件循环" aria-hidden="true">#</a> 事件循环</h1><h2 id="定义" tabindex="-1"><a class="header-anchor" href="#定义" aria-hidden="true">#</a> 定义</h2><p>Event Loop是 user agent(浏览器)用于协调事件，用户交互(鼠标、键盘)，脚本（JS）， 渲染（如HTML、CSS样式），网络等行为的一种机制。</p><h2 id="任务的类型" tabindex="-1"><a class="header-anchor" href="#任务的类型" aria-hidden="true">#</a> 任务的类型</h2><p>任务分为宏任务(macrotask)和微任务(microtask)。 宏任务有：script、setTimeout/setInterval、setImmediate、I/O、UI rendering; 微任务有：Promise、Object.observe、MutationObserver、postMessage。</p><p>tips: 一个Event Loop有一个或多个任务队列，每个任务队列有一个微任务队列。</p><h2 id="event-loop处理模型" tabindex="-1"><a class="header-anchor" href="#event-loop处理模型" aria-hidden="true">#</a> Event Loop处理模型</h2><ul><li>步骤1: 判断当前任务队列是否为空。</li><li>步骤2: 如果为空，则执行步骤3。如果不为空，则执行任务队列中入栈最早的任务A，任务A执行完之后，继续执行步骤2。</li><li>步骤3: 将事件循环当前执行任务设置为 null。进入微任务队列，判断微任务队列是否为空。</li><li>步骤4: 如果为空，则执行步骤5。如果不为空，则执行微任务队列中入栈最早的任务A，任务A执行完之后，继续执行步骤4。</li><li>步骤5: 判断是否需要调用 requestAnimationFrame 重新渲染。</li><li>步骤6: 结束之后，返回继续执行步骤1。</li></ul><h2 id="图示" tabindex="-1"><a class="header-anchor" href="#图示" aria-hidden="true">#</a> 图示</h2><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',10),s=[o];function l(d,c){return a(),t("div",null,s)}const p=e(n,[["render",l],["__file","event-loop.html.vue"]]);export{p as default};
