import{_ as n,V as a,W as s,a0 as l}from"./framework-afccc25a.js";const i={},t=l(`<h1 id="前言" tabindex="-1"><a class="header-anchor" href="#前言" aria-hidden="true">#</a> 前言</h1><h2 id="代码与设计模式的关系" tabindex="-1"><a class="header-anchor" href="#代码与设计模式的关系" aria-hidden="true">#</a> 代码与设计模式的关系</h2><ul><li>项目 = 模块 + 沟通 （设计模式可以帮助我们更好得编写模块以及设计模块间的沟通）</li></ul><h2 id="设计模式扮演的角色" tabindex="-1"><a class="header-anchor" href="#设计模式扮演的角色" aria-hidden="true">#</a> 设计模式扮演的角色</h2><ul><li>帮助我们组织模块 <ul><li>通过一些设计模式，组织模块间的组成结构</li></ul></li><li>帮助我们设计沟通 <ul><li>有的设计模式可以帮助我们设计模块如何沟通</li></ul></li><li>提高代码质量 <ul><li>通过设计模式，让代码更加优雅</li></ul></li></ul><h2 id="设计原则" tabindex="-1"><a class="header-anchor" href="#设计原则" aria-hidden="true">#</a> 设计原则</h2><ul><li>开闭原则 <ul><li>对扩展开放，对修改关闭。要留出具体使用时可供扩展的接口，但是要封装源码，不能给外部修改。</li></ul></li><li>单一职责原则 <ul><li>一个模块只做一件事情</li><li>关注对象：模块本身</li></ul></li><li>依赖倒置原则 <ul><li>核心思想：上层模块不要依赖于具体的下层模块，而应该依赖于抽象。</li><li>实现思路：在上层模块与下层模块之间添加抽象层，从而保证了上层模块不会由于下层模块的改动而发生剧烈变动。</li><li>举个🌰</li></ul><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code>  <span class="token keyword">function</span> <span class="token function">food1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">function</span> <span class="token function">food2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  order<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">orderFood1</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  order<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">orderFood2</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">resturn</span><span class="token punctuation">(</span><span class="token parameter">food</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> list <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">food1</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">food1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
      <span class="token literal-property property">food2</span><span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">food2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> list<span class="token punctuation">[</span>food<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">order</span><span class="token punctuation">(</span><span class="token parameter">order</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">resturn</span><span class="token punctuation">(</span>food<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li>接口隔离原则 <ul><li>接口应该细化，功能应该单一。</li><li>关注对象：接口本身。</li></ul></li><li>迪米特法则 <ul><li>两个模块可以在不互相了解彼此细节的情况下，通过中介等方式进行间接沟通</li></ul></li><li>里氏替换原则 <ul><li>关注点：继承</li><li>任何父类使用的地方，都可以用子类去替换。因此要求，子类需要完全继承父类的属性和方法。</li></ul></li></ul><h2 id="设计模式的分类" tabindex="-1"><a class="header-anchor" href="#设计模式的分类" aria-hidden="true">#</a> 设计模式的分类</h2><ul><li><p>创建型 - 优雅地创建对象</p><ul><li>工厂模式 - 大量创建对象</li><li>单例模块 - 全局只能有我一个</li><li>建造者模式 - 精细化组合对象</li><li>原型模式 - JavaScript的灵魂</li></ul></li><li><p>结构型 - 优雅地设计代码结构</p><ul><li>外观模式 - 给你的一个套餐</li><li>享元模式 - 通过共享来减少数量（对象/代码块）</li><li>适配者模式 - 用适配代替更改（适配新旧接口）</li><li>桥接模式 - 独立出来，然后再对接过去（减少耦合）</li><li>装饰者模式 - 更优雅地扩展需求</li></ul></li><li><p>行为型 - 模块之间行为的模式总结，帮助我们组织模块行为</p><ul><li>观察者模式 - 我作为第三方转发</li><li>职责链模式 - 像生产线一样组织模块，对模块进行增删改</li><li>状态模式 - 用状态代替判断</li><li>命令模式 - 用命令去解耦（执行者与命令者）</li><li>策略模式 - 算法工厂</li><li>迭代器模式 - 告别for循环（不了解对象内部就可以遍历对象）</li></ul></li><li><p>技巧型 - 优化代码的技巧</p><ul><li>链模式 - 链式调用</li><li>惰性模式 - 我要搞机器学习（记录执行状态）</li><li>委托模式 - 让别人代替你收快递</li><li>等待者模式 - 等你吗都回来再吃饭（多个异步）</li><li>数据访问模式 - 一个方便的数据管理器</li></ul></li></ul>`,9),p=[t];function e(o,c){return a(),s("div",null,p)}const r=n(i,[["render",e],["__file","preface.html.vue"]]);export{r as default};
